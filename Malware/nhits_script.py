import sys
import torch
import pytorch_forecasting as pf
from preprocessing import preprocess
import matplotlib.pyplot as plt
from torch import nn
from matplotlib.backends.backend_pdf import PdfPages
from sklearn.metrics import mean_absolute_error, root_mean_squared_error, mean_absolute_percentage_error
import pandas as pd
from __init__ import attack
from predict import predict
import numpy as np

if __name__ == '__main__':
    if len(sys.argv) < 2:
        print("No Recording Given.....")
    else:
        if len(sys.argv) > 2:
            output_path = sys.argv[2]
        else:
            output_path = '.'
        recording = sys.argv[1]
        model_state_dict = torch.load("./NHITS_forecasting_model.pt")
        params = torch.load("./NHITS_params.pt", weights_only=False)
        params["loss"] = pf.QuantileLoss(quantiles=[0.001, 0.01, 0.05, 0.5, 0.95, 0.99, 0.999])
        model = pf.NHiTS(**params)
        model.load_state_dict(model_state_dict)
        model.eval()


        predictions, ticker, adjprc = predict(model, recording)
        lookback_length = model.hparams["context_length"]
        predictions = predictions.numpy()
        adjprc = adjprc.numpy()

        # Calculate the errors
        mae = mean_absolute_error(adjprc[lookback_length:], predictions)
        rmse = root_mean_squared_error(adjprc[lookback_length:], predictions)
        mape = mean_absolute_percentage_error(adjprc[lookback_length:], predictions)

        index = np.arange(lookback_length, len(predictions) + lookback_length)

        fig = plt.figure(figsize=(14, 6))
        plt.plot(index, adjprc[lookback_length:], label="Actual", color="blue")
        plt.plot(index, predictions, label="Predicted", color="orange")
        plt.title(f"Predicted vs Actual for stock {ticker[0]} (all), MAE: {mae}")
        plt.legend()
        plt.xlabel("Day")
        plt.ylabel("adjprc")
        plt.savefig(f"{output_path}/forecast_plot_{ticker[0]}.png")
        plt.close()

        with open(f"{output_path}/metrics_{ticker[0]}.txt", 'w') as file:
            file.write(f"MAE: {mae}\n")
            file.write(f"RMSE: {rmse}\n")
            file.write(f"MAPE: {mape}\n ")

        # dataset = preprocess(recording)
        # attack(dataset, model)
        # predictions = model.predict(dataset, return_x=True, mode="prediction", trainer_kwargs=dict(accelerator="cpu"))


        # # Get all our test tickers
        # tickers = dataset.decoded_index["ticker"].unique()

        # # Get the times, predictions and ground truth values
        # time_idx = predictions.x["decoder_time_idx"]
        # actuals = predictions.x["decoder_target"]
        # preds = predictions.output

        # # by def, each time_idx must start at 300 since it is the max encoder length
        # starts = torch.argwhere(time_idx[:, 0] == 300)
        # ends = torch.cat([(starts)[1:, :], torch.tensor([len(time_idx)]).unsqueeze(-1)], dim=0)
        # starts_and_ends = torch.cat([starts, ends], dim=1)

        
        # for start, end in starts_and_ends:
        #     corresponding_time = time_idx[start:end].flatten().numpy()
        #     corresponding_actuals = actuals[start:end].flatten().numpy()
        #     corresponding_pred = preds[start:end].flatten().numpy()

        #     df = pd.DataFrame({
        #         "time": corresponding_time,
        #         "Actual": corresponding_actuals,
        #         "Prediction": corresponding_pred
        #     })
        #     # Group by time and find the average
        #     df = df.groupby("time").agg({
        #         "Prediction" : 'mean',
        #         'Actual': 'mean'
        #     })
        #     # Calculate the errors
        #     mae = mean_absolute_error(df["Actual"], df["Prediction"])
        #     rmse = root_mean_squared_error(df["Actual"], df["Prediction"])
        #     mape = mean_absolute_percentage_error(df["Actual"], df["Prediction"])

        #     fig = plt.figure(figsize=(14, 6))
        #     plt.plot(df.index, df["Actual"], label="Actual", color="blue")
        #     plt.plot(df.index, df["Prediction"], label="Predicted", color="orange")
        #     plt.title(f"Predicted vs Actual for stock {tickers[0]} (all), MAE: {mae}")
        #     plt.legend()
        #     plt.xlabel("Day")
        #     plt.ylabel("adjprc")
        #     plt.savefig(f"{output_path}/forecast_plot.png")
        #     plt.close()

        #     df.to_csv(f"{output_path}/{tickers[0]}.csv")

        #     with open(f"{output_path}/metrics.txt", 'w') as file:
        #         file.write(f"MAE: {mae}\n")
        #         file.write(f"RMSE: {rmse}\n")
        #         file.write(f"MAPE: {mape}\n ")
                

